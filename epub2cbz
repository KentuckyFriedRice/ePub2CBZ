#!/bin/bash
#------------------------------Functions---------------------------------------
epub2cbz_converter() {
	OPTIND=1
	#default values
	japaneseMode=0
	filename=""
	originalDir=""
	temp=""
	imageDir=""
	cover=""

	#options
	while getopts "c:ij" opt; do
		case $opt in
			j) japaneseMode=1 ;;
			i) imageDir="ordered_images" ;;
			c) cover="$originalDir/$OPTARG" ;;
			*) exit 1 ;;
		esac
	done
	#Shifts options down one so filename will be set correctly
	shift $((OPTIND - 1))

	#gets user input for the file path
	filename="${!#}"

	#gets the absolute path of the file, then splits it to the filename and the path of the file then changes into that path
	originalDir=$(readlink -f $filename)
	filename=${originalDir##*/}
	originalDir="${originalDir%/*}/"

	cd $originalDir || exit

	#Tests if we will be pasting them backwards then gives a quote from JoJo to confirm to the user Japanese mode is recognized and enabled.
	if [ $japaneseMode -eq 1 ]; then
		echo "ほう… 向かってくるのか…　逃げずにこのソフトに近づいてくるのか…"
	fi

	#Gives feedback to the user. This also gently implies that a directory was made and as the known problem section on github states in the event of a termination, the directory won't be deleted automatically.
	echo "Making working directory"
	mkdir -p .working_$$

	#This strips filename of the epub extension and adds .zip instead.
	temp="${filename%.epub}.zip"

	#This copies the file to convert into the working directory as a zip file.
	cp -f "$filename" ".working_$$/${filename%.epub}.zip"
	filename="$temp"

	cd ".working_$$" || exit

	#unzips the file in quiet mode and suppresses output
	unzip -oq "$filename"

	#Lets the user know we are now working directly with pictures
	echo "copying images"
	mkdir -p pics

	#By default "" is the imageDir. But in jumbled mode (-i), it needs to be ordered_images because that is what imageRenamer creates and uses to deshuffle the images. Therefore if the user uses jumbled mode, it is set to ordered_images. The first if statement basically checks if imageDir is set to ordered_images. If so it proceeds with the deshuffling process. Otherwise it moves to the second if statement which looks for the images directory. If it's not there, the images are likely in the root of the document so it works with "".
	if [ -n "$imageDir" ]; then
		echo "Reorganizing images"
		imageRenamer "$(pwd)"
	fi

	if [ -z "$imageDir" ]; then
		imageDir=$(find . -type d -name images)
	fi

	# copies everything in the imageDir to pics
	cp -f $imageDir/* pics/

	cd pics || exit

	mkdir -p new

	#Adds all images with .jpeg, .jpg, and .png extensions to an array called fileList and sorts them.
	readarray -t fileList < <(find . -maxdepth 1 -type f \( -iname '*.jpeg' -o -iname '*.jpg' -o -iname '*.png' \) | sort -V | cut -c3-)
	fileListLength=${#fileList[@]}

	#placeholder for image count. Starts images' filename at 1 because 0 will be used as the cover.
	imageCount=1
	barWidth=40

	startNum=0

	#If a custom cover is added via option, It's set here and also tells the user which file it will be using just in case. It establishes that the cover is recognized and confirms the cover file's location.
	if [ -n "$cover" ]; then
		echo "This is the cover $cover"
	fi

	#Often times the cover is the first image in the images folder but sometimes it is named cover.jpg or something.
	if [ -z "$cover" ]; then
		coverCheck=$(find "$originalDir/.working_$$/" -type f -iname cover.jpeg | head -n 1)
		if [ -n "$coverCheck" ]; then
			cover="$coverCheck"
		else
			cover="${fileList[0]}"
		fi
		startNum=1
	fi

	#adds the cover to the new folder as 0.png also converts it to png.
	magick "$cover" "new/0.png"

	echo "Working..."

	#This section appends two pages together. Sometimes it is tricky to get them to line up as intended by the author so you might need to remove a blank page manually from the epub file. Additionally, I am not sure why I started with 2.
	#
	#Japanese mode appends the page order backwards because Japanese books go right-to-left.
	for i in $(seq $startNum 2 $((fileListLength-1)))
	do
		if [ $((i + 1)) -le $((fileListLength-1)) ]; then

			if [ "$japaneseMode" -eq 1 ]; then
				magick "${fileList[i+1]}" "${fileList[i]}" +append "new/${imageCount}.png"
			else
				magick "${fileList[i]}" "${fileList[i+1]}" +append "new/${imageCount}.png"
			fi
			imageCount=$((imageCount+1))

		else
			magick "${fileList[i]}" new/${imageCount}.png
		fi
	#This is the status bar. It lets the user know how the conversion is progressing.
		percent=$(( (i + 1) * 100 / fileListLength ))
		filled=$((percent * barWidth / 100))
		empty=$((barWidth - filled))
		bar=$(printf "%0.s#" $(seq 1 $filled))
		space=$(printf "%0.s-" $(seq 1 $empty))

		printf "\r[%s%s] %3d%%" "$bar" "$space" "$percent"
	done

	#Since It is finished after the loop is done, I just have it go to 100% here.
	bar=$(printf "%0.s#" $(seq 1 $barWidth))
	printf "\r[%s] - 100%% Done!\n" "$bar"

	#Since reading from right-to-left is up to the software, it may not always be an option. So here I decided to add the cover again to the end and reverse the image order. That way you can just shoot to the very end of the file so that you can read the book from the end to simulate reading right-to-left.
	if [ "$japaneseMode" -eq 1 ]; then

		echo "Reversing Image Order..."

		imageCount=$((imageCount+1))
		magick "$cover" "new/${imageCount}.png"

		readarray -t fileList < <(find new -maxdepth 1 -type f \( -name '*.jpeg' -o -name '*.jpg' -o -name '*.png' \) | sort -V)

		# Reverse the array
		for ((i=0, j=${#fileList[@]}-1; i<j; i++, j--)); do
			tmp="tmp_$i"
			mv "${fileList[i]}" "$tmp"             # move first to tmp
			mv "${fileList[j]}" "${fileList[i]}"      # move last to first
			mv "$tmp" "${fileList[j]}"             # move tmp to last

		done
	fi

	#This is where the file is actually made as a cbz and moved into the converted folder.
	echo "Finishing up..."

	filename=${filename%.zip}.cbz

	zip -q "$filename" new/*


	mkdir -p "$originalDir"/converted
	mv "$filename" "$originalDir"/converted

	#Clean up
	cd "$originalDir" || exit
	rm -r .working_$$/*
	rmdir  .working_$$

	echo "Finished! Enjoy Reading :)"

}

imageRenamer() {
	currentDir=pwd

	if [ -n $1 ]; then
		current=$1
	fi
	current=$1

	#Getting the naming convention fo the html files
	first="$(find . -maxdepth 1 \( -name '*1*.html' -o -name '*1*.xhtml' \) | head -n1)"
	prefix="$(echo "$first" | sed -E 's/[0-9]+.*//')"
	prefix="${prefix/.\//}"
	#echo "Prefix is $prefix"
	extension=".${first##*.}"
	#echo "Extension is $extension"

	# Folder where your HTML files are
	html_dir="."

	# Folder where images are stored relative to HTML files
	img_dir="$html_dir/images"

	# Destination folder for copied images
	dest_dir="$1/ordered_images"

	mkdir -p "$dest_dir"

	for html_file in "$html_dir"/"$prefix"*"$extension"; do
		# Extract number from filename, e.g. 000 from index_split_000.html
		num="${html_file/$prefix/}"
		num="${num%$extension}"

		# Extract the image filename from the <img src="..."> tag
		img_name=$(sed -n 's/.*<img src="images\/\([^"]*\)".*/\1/p' "$html_file")

		if [ -z "$img_name" ]; then
			#echo "No image found in $html_file"
			continue
		fi

		# Source image path
		src_img="$img_dir/$img_name"

		#Checks if the source image exists
		if [ ! -f "$src_img" ]; then
			echo "Image $src_img not found!"
			continue
		fi

		# Destination image path, e.g. 000.jpg, 001.jpg, ...
		dest_img="$dest_dir/${num}.jpg"

		cp "$src_img" "$dest_img"
	done
}

#----------------------------Main Execution------------------------------------
OPTIND=1

#Is the user asking to use a directory?
isDirectory=0

#options to pass on to epub2cbz_converter
options=""

#Collects options and sets variables for the next steps; echos usage if there is an error in how options are used
while getopts "c:dji" opt; do
	case $opt in
		c) options+=" -c $OPTARG" ;;
		i) options+=" -i" ;;
		d) isDirectory=1 ;;
		j) options+=" -j" ;;
		*)
		  echo "Usage: $0 [-i jumbled] [-j Japan_mode] [-d directory] [file.epub | directory]"
		  exit 1
		;;
	esac
done

#shifts options down done
shift $((OPTIND - 1))

#sets the filename or directory as variable "input."
input=${!#}

#Checks if directory exists and executes epub2cbz_converter with options
if [ $isDirectory -eq 1 ]; then
	if [ ! -d $input ]; then
		echo "Directory not found"
		exit 1
	fi
	
	#changes working directory to user's directory
	cd $input

	#sets options removes space
	options=${options# }

	#converts all epub files in the directory
	for epub in *.epub; do
		epub2cbz_converter $options "$epub"
	done

fi

#Checks if the file exists and if so converts the file using the options.
if [ $isDirectory -eq 0 ]; then
	if [ ! -f "$input" ]; then
		echo "File not found"
		exit 1
	fi
	if [ ".${input##*.}" != ".epub" ]; then
		echo "Not an epub"
		exit 1
	fi
	
	options=${options# }
	epub2cbz_converter $options "$input"
fi
