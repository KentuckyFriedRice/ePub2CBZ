#!/bin/bash

#default values
japaneseMode=0
filename=""
originalDir=""
temp=""
imageDir=""
cover=""

#options
while getopts "c:ij" opt; do
	case $opt in
 		j) japaneseMode=1 ;;
		i) imageDir="ordered_images" ;;
		c) cover="$originalDir/$OPTARG" ;;
		*) exit 1 ;;
   	esac
done
#Shifts options down one so filename will be set correctly
shift $((OPTIND - 1))

#gets user input for the file path
filename="${!#}"

#gets the absolute path of the file, then splits it to the filename and the path of the file then changes into that path
originalDir=$(readlink -f $filename)
filename=${originalDir##*/}
originalDir="${originalDir%/*}/"

cd $originalDir || exit

#Tests if we will be pasting them backwards then gives a quote from JoJo to confirm to the user Japanese mode is recognized and enabled.
if [ $japaneseMode -eq 1 ]; then
	echo "ほう… 向かってくるのか…　逃げずにこのソフトに近づいてくるのか…"
fi

#Gives feedback to the user. This also gently implies that a directory was made and as the known problem section on github states in the event of a termination, the directory won't be deleted automatically.
echo "Making working directory"
mkdir -p .working_$$

#This strips filename of the epub extension and adds .zip instead.
temp="${filename%.epub}.zip"

#This copies the file to convert into the working directory as a zip file.
cp -f "$filename" ".working_$$/${filename%.epub}.zip"
filename="$temp"

cd ".working_$$" || exit

#unzips the file in quiet mode and suppresses output
unzip -oq "$filename"

#Lets the user know we are now working directly with pictures
echo "copying images"
mkdir -p pics

#By default "" is the imageDir. But in jumbled mode (-i), it needs to be ordered_images because that is what imageRenamer creates and uses to deshuffle the images. Therefore if the user uses jumbled mode, it is set to ordered_images. The first if statement basically checks if imageDir is set to ordered_images. If so it proceeds with the deshuffling process. Otherwise it moves to the second if statement which looks for the images directory. If it's not there, the images are likely in the root of the document so it works with "".
if [ -n "$imageDir" ]; then
	echo "Reorganizing images"
	imageRenamer "$(pwd)"
fi

if [ -z "$imageDir" ]; then
	imageDir=$(find . -type d -name images)
fi

# copies everything in the imageDir to pics
cp -f $imageDir/* pics/

cd pics || exit

mkdir -p new

#Adds all images with .jpeg, .jpg, and .png extensions to an array called fileList and sorts them.
readarray -t fileList < <(find . -maxdepth 1 -type f \( -iname '*.jpeg' -o -iname '*.jpg' -o -iname '*.png' \) | sort -V | cut -c3-)
fileListLength=${#fileList[@]}

#placeholder for image count. Starts images' filename at 1 because 0 will be used as the cover.
imageCount=1
barWidth=40

startNum=0

#If a custom cover is added via option, It's set here and also tells the user which file it will be using just in case. It establishes that the cover is recognized and confirms the cover file's location.
if [ -n "$cover" ]; then
	echo "This is the cover $cover"
fi

#Often times the cover is the first image in the images folder but sometimes it is named cover.jpg or something.
if [ -z "$cover" ]; then
	coverCheck=$(find "$originalDir/.working_$$/" -type f -iname cover.jpeg | head -n 1)
	if [ -n "$coverCheck" ]; then
		cover="$coverCheck"
	else
		cover="${fileList[0]}"
	fi
	startNum=1
fi

#adds the cover to the new folder as 0.png also converts it to png.
magick "$cover" "new/0.png"

echo "Working..."

#This section appends two pages together. Sometimes it is tricky to get them to line up as intended by the author so you might need to remove a blank page manually from the epub file. Additionally, I am not sure why I started with 2.
#
#Japanese mode appends the page order backwards because Japanese books go right-to-left.
for i in $(seq $startNum 2 $((fileListLength-1)))
do
	if [ $((i + 1)) -le $((fileListLength-1)) ]; then
		
		if [ "$japaneseMode" -eq 1 ]; then
			magick "${fileList[i+1]}" "${fileList[i]}" +append "new/${imageCount}.png"
		else
			magick "${fileList[i]}" "${fileList[i+1]}" +append "new/${imageCount}.png"
		fi
		imageCount=$((imageCount+1))

	else
		magick "${fileList[i]}" new/${imageCount}.png
	fi
#This is the status bar. It lets the user know how the conversion is progressing.
	percent=$(( (i + 1) * 100 / fileListLength ))
    	filled=$((percent * barWidth / 100))
    	empty=$((barWidth - filled))
    	bar=$(printf "%0.s#" $(seq 1 $filled))
    	space=$(printf "%0.s-" $(seq 1 $empty))

    	printf "\r[%s%s] %3d%%" "$bar" "$space" "$percent"
done

#Since It is finished after the loop is done, I just have it go to 100% here.
bar=$(printf "%0.s#" $(seq 1 $barWidth))
printf "\r[%s] - 100%% Done!\n" "$bar"

#Since reading from right-to-left is up to the software, it may not always be an option. So here I decided to add the cover again to the end and reverse the image order. That way you can just shoot to the very end of the file so that you can read the book from the end to simulate reading right-to-left.
if [ "$japaneseMode" -eq 1 ]; then
	
	echo "Reversing Image Order..."

	imageCount=$((imageCount+1))
	magick "$cover" "new/${imageCount}.png"
	
	readarray -t fileList < <(find new -maxdepth 1 -type f \( -name '*.jpeg' -o -name '*.jpg' -o -name '*.png' \) | sort -V)

	# Reverse the array
	for ((i=0, j=${#fileList[@]}-1; i<j; i++, j--)); do
    		tmp="tmp_$i"
    		mv "${fileList[i]}" "$tmp"             # move first to tmp
    		mv "${fileList[j]}" "${fileList[i]}"      # move last to first
    		mv "$tmp" "${fileList[j]}"             # move tmp to last

	done
fi

#This is where the file is actually made as a cbz and moved into the converted folder.
echo "Finishing up..."

filename=${filename%.zip}.cbz

zip -q "$filename" new/*


mkdir -p "$originalDir"/converted
mv "$filename" "$originalDir"/converted

#Clean up
cd "$originalDir" || exit
rm -r .working_$$/*
rmdir  .working_$$

echo "Finished! Enjoy Reading :)"
